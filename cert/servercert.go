// Code generated by bencgen go. DO NOT EDIT.
// source: server_certificate.benc

package cert

import (
    "github.com/deneonet/benc/std"
    "github.com/deneonet/benc/impl/gen"


)

// Struct - ServerCertificate
type ServerCertificate struct {
    PublicKey []byte
    PrivateKey []byte
    PublicKeySignature []byte
    Version int
    CreatedAt int64
}

// Reserved Ids - ServerCertificate
var serverCertificateRIds = []uint16{}

// Size - ServerCertificate
func (serverCertificate *ServerCertificate) Size() int {
    return serverCertificate.NestedSize(0)
}

// Nested Size - ServerCertificate
func (serverCertificate *ServerCertificate) NestedSize(id uint16) (s int) {
    s += bstd.SizeBytes(serverCertificate.PublicKey) + 2
    s += bstd.SizeBytes(serverCertificate.PrivateKey) + 2
    s += bstd.SizeBytes(serverCertificate.PublicKeySignature) + 2
    s += bstd.SizeInt(serverCertificate.Version) + 2
    s += bstd.SizeInt64() + 2

    if id > 255 {
        s += 5
        return
    }
    s += 4
    return
}

// SizePlain - ServerCertificate
func (serverCertificate *ServerCertificate) SizePlain() (s int) {
    s += bstd.SizeBytes(serverCertificate.PublicKey)
    s += bstd.SizeBytes(serverCertificate.PrivateKey)
    s += bstd.SizeBytes(serverCertificate.PublicKeySignature)
    s += bstd.SizeInt(serverCertificate.Version)
    s += bstd.SizeInt64()
    return
}

// Marshal - ServerCertificate
func (serverCertificate *ServerCertificate) Marshal(b []byte) {
    serverCertificate.NestedMarshal(0, b, 0)
}

// Nested Marshal - ServerCertificate
func (serverCertificate *ServerCertificate) NestedMarshal(tn int, b []byte, id uint16) (n int) {
    n = bgenimpl.MarshalTag(tn, b, bgenimpl.Container, id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 1)
    n = bstd.MarshalBytes(n, b, serverCertificate.PublicKey)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 2)
    n = bstd.MarshalBytes(n, b, serverCertificate.PrivateKey)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 3)
    n = bstd.MarshalBytes(n, b, serverCertificate.PublicKeySignature)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Varint, 4)
    n = bstd.MarshalInt(n, b, serverCertificate.Version)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed64, 5)
    n = bstd.MarshalInt64(n, b, serverCertificate.CreatedAt)

    n += 2
    b[n-2] = 1
    b[n-1] = 1
    return
}

// MarshalPlain - ServerCertificate
func (serverCertificate *ServerCertificate) MarshalPlain(tn int, b []byte) (n int) {
    n = tn
    n = bstd.MarshalBytes(n, b, serverCertificate.PublicKey)
    n = bstd.MarshalBytes(n, b, serverCertificate.PrivateKey)
    n = bstd.MarshalBytes(n, b, serverCertificate.PublicKeySignature)
    n = bstd.MarshalInt(n, b, serverCertificate.Version)
    n = bstd.MarshalInt64(n, b, serverCertificate.CreatedAt)
    return n
}

// Unmarshal - ServerCertificate
func (serverCertificate *ServerCertificate) Unmarshal(b []byte) (err error) {
    _, err = serverCertificate.NestedUnmarshal(0, b, []uint16{}, 0)
    return
}

// Nested Unmarshal - ServerCertificate
func (serverCertificate *ServerCertificate) NestedUnmarshal(tn int, b []byte, r []uint16, id uint16) (n int, err error) {
    var ok bool
    if n, ok, err = bgenimpl.HandleCompatibility(tn, b, r, id); !ok {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, serverCertificateRIds, 1); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, serverCertificate.PublicKey, err = bstd.UnmarshalBytes(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, serverCertificateRIds, 2); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, serverCertificate.PrivateKey, err = bstd.UnmarshalBytes(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, serverCertificateRIds, 3); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, serverCertificate.PublicKeySignature, err = bstd.UnmarshalBytes(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, serverCertificateRIds, 4); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, serverCertificate.Version, err = bstd.UnmarshalInt(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, serverCertificateRIds, 5); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, serverCertificate.CreatedAt, err = bstd.UnmarshalInt64(n, b); err != nil {
            return
        }
    }
    n += 2
    return
}

// UnmarshalPlain - ServerCertificate
func (serverCertificate *ServerCertificate) UnmarshalPlain(tn int, b []byte) (n int, err error) {
    n = tn
    if n, serverCertificate.PublicKey, err = bstd.UnmarshalBytes(n, b); err != nil {
        return
    }
    if n, serverCertificate.PrivateKey, err = bstd.UnmarshalBytes(n, b); err != nil {
        return
    }
    if n, serverCertificate.PublicKeySignature, err = bstd.UnmarshalBytes(n, b); err != nil {
        return
    }
    if n, serverCertificate.Version, err = bstd.UnmarshalInt(n, b); err != nil {
        return
    }
    if n, serverCertificate.CreatedAt, err = bstd.UnmarshalInt64(n, b); err != nil {
        return
    }
    return
}

